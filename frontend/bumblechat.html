<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BumbleChat</title>
    <link rel="stylesheet" href="/static/css/styles.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
    <div id="app-container">
        <!-- èŠå¤©æ¶ˆæ¯åŒºåŸŸ -->
        <div id="chat-container">
            <!-- é¡¶éƒ¨ç™½è‰²é®ç½©æ¡ -->
            <div id="top-overlay">
                <div id="top-overlay-text">ğŸ BumbleChat</div>
            </div>
            <div id="messages"></div>
        </div>
        
        <!-- è¾“å…¥åŒºåŸŸ -->
        <div id="input-container" class="centered">
            <div id="input-wrapper">
                <textarea 
                    id="user-input" 
                    placeholder="ä¸BumbleBeeèŠå¤©"
                    rows="1"
                ></textarea>
                <button id="send-button" title="å‘é€">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="22" y1="2" x2="11" y2="13"></line>
                        <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        const chatContainer = document.getElementById('chat-container');
        const messagesContainer = document.getElementById('messages');
        const inputContainer = document.getElementById('input-container');
        const inputWrapper = document.getElementById('input-wrapper');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        
        // ç”Ÿæˆæˆ–è·å– session ID
        let sessionId = localStorage.getItem('sessionId');
        if (!sessionId) {
            sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('sessionId', sessionId);
        }

        // è‡ªåŠ¨è°ƒæ•´è¾“å…¥æ¡†é«˜åº¦
        function adjustInputHeight() {
            userInput.style.height = 'auto';
            userInput.style.height = userInput.scrollHeight + 'px';
            // è¾“å…¥æ¡†é«˜åº¦å˜åŒ–æ—¶ï¼Œæ›´æ–°æ¶ˆæ¯å®¹å™¨çš„ padding
            updateMessagesPadding();
        }

        userInput.addEventListener('input', adjustInputHeight);
        
        // ç›‘å¬çª—å£å¤§å°å˜åŒ–ï¼Œæ›´æ–° padding
        window.addEventListener('resize', () => {
            updateMessagesPadding();
        });

        // æ›´æ–°æ¶ˆæ¯å®¹å™¨çš„åº•éƒ¨ paddingï¼Œé˜²æ­¢ä¸è¾“å…¥æ¡†é‡å 
        function updateMessagesPadding() {
            if (inputContainer.classList.contains('bottom')) {
                // ä½¿ç”¨ requestAnimationFrame ç¡®ä¿ DOM æ›´æ–°å®Œæˆåå†è®¡ç®—
                requestAnimationFrame(() => {
                    // è®¡ç®—è¾“å…¥æ¡†çš„å®é™…é«˜åº¦
                    const inputHeight = inputContainer.offsetHeight;
                    // è®¾ç½®åº•éƒ¨ paddingï¼Œç•™å‡ºä¸€äº›é¢å¤–ç©ºé—´
                    messagesContainer.style.paddingBottom = (inputHeight + 20) + 'px';
                });
            } else {
                // è¾“å…¥æ¡†å±…ä¸­æ—¶ï¼Œä½¿ç”¨é»˜è®¤ padding
                messagesContainer.style.paddingBottom = '20px';
            }
        }

        // å°†è¾“å…¥æ¡†ç§»åˆ°åº•éƒ¨
        function moveInputToBottom() {
            inputContainer.classList.remove('centered');
            inputContainer.classList.add('bottom');
            // å»¶è¿Ÿæ›´æ–° paddingï¼Œç¡®ä¿ DOM æ›´æ–°å®Œæˆ
            setTimeout(() => {
                updateMessagesPadding();
            }, 100);
        }

        // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦åœ¨åº•éƒ¨é™„è¿‘ï¼ˆå…è®¸50pxçš„è¯¯å·®ï¼‰
        function isNearBottom() {
            const threshold = 50;
            const scrollTop = chatContainer.scrollTop;
            const scrollHeight = chatContainer.scrollHeight;
            const clientHeight = chatContainer.clientHeight;
            return (scrollHeight - scrollTop - clientHeight) < threshold;
        }

        // æ»šåŠ¨åˆ°åº•éƒ¨ï¼ˆä»…åœ¨ç”¨æˆ·å·²ç»åœ¨åº•éƒ¨é™„è¿‘æ—¶ï¼‰
        function scrollToBottomIfNeeded() {
            if (isNearBottom()) {
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }
        }

        // å¼ºåˆ¶æ»šåŠ¨åˆ°åº•éƒ¨ï¼ˆç”¨äºæ–°æ¶ˆæ¯ï¼‰
        function scrollToBottom() {
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©åŒºåŸŸ
        function addMessage(role, content, isStreaming = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            if (isStreaming) {
                contentDiv.innerHTML = '<div class="typing-indicator"><span></span><span></span><span></span></div>';
            } else {
                // ä½¿ç”¨ marked è§£æ markdown
                if (role === 'assistant') {
                    contentDiv.innerHTML = marked.parse(content);
                } else {
                    contentDiv.textContent = content;
                }
            }
            
            messageDiv.appendChild(contentDiv);
            messagesContainer.appendChild(messageDiv);
            
            // æ–°æ¶ˆæ¯æ—¶æ€»æ˜¯æ»šåŠ¨åˆ°åº•éƒ¨
            scrollToBottom();
            
            return contentDiv;
        }

        // æ›´æ–°æ¶ˆæ¯å†…å®¹ï¼ˆæµå¼è¾“å‡ºæ—¶ï¼Œåªåœ¨åº•éƒ¨é™„è¿‘æ‰æ»šåŠ¨ï¼‰
        function updateMessage(element, content) {
            element.innerHTML = marked.parse(content);
            scrollToBottomIfNeeded();
        }

        // å‘é€æ¶ˆæ¯
        async function sendMessage() {
            const message = userInput.value.trim();
            if (!message || sendButton.disabled) return;

            // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡å‘é€ï¼Œå°†è¾“å…¥æ¡†ç§»åˆ°åº•éƒ¨
            if (inputContainer.classList.contains('centered')) {
                moveInputToBottom();
            }

            // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
            addMessage('user', message);
            
            // æ¸…ç©ºè¾“å…¥æ¡†
            userInput.value = '';
            adjustInputHeight();
            
            // ç¦ç”¨å‘é€æŒ‰é’®
            sendButton.disabled = true;

            // æ·»åŠ åŠ©æ‰‹æ¶ˆæ¯å ä½ç¬¦
            // addMessage è¿”å›çš„æ˜¯ contentDivï¼Œæ‰€ä»¥ç›´æ¥ä½¿ç”¨
            const assistantContentDiv = addMessage('assistant', '', true);
            assistantContentDiv.innerHTML = '';

            let accumulatedText = '';

            try {
                const response = await fetch('/chat/stream?session_id=' + encodeURIComponent(sessionId), {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        messages: message,
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder('utf-8');
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    
                    // ä¿ç•™æœ€åä¸€è¡Œï¼ˆå¯èƒ½ä¸å®Œæ•´ï¼‰
                    buffer = lines.pop() || '';

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const dataStr = line.slice(6);
                            if (dataStr.trim() === '') continue;
                            
                            try {
                                const data = JSON.parse(dataStr);
                                
                                if (data.token !== undefined) {
                                    accumulatedText += data.token;
                                    updateMessage(assistantContentDiv, accumulatedText);
                                } else if (data.done) {
                                    console.log('Stream completed');
                                    // æµå¼è¾“å‡ºå®Œæˆåï¼Œç¡®ä¿æ»šåŠ¨åˆ°åº•éƒ¨
                                    scrollToBottom();
                                } else if (data.error) {
                                    assistantContentDiv.innerHTML = '<p style="color: #ff0000;">é”™è¯¯: ' + data.error + '</p>';
                                    break;
                                }
                            } catch (e) {
                                console.error('Parse error:', e, 'Data:', dataStr);
                            }
                        }
                    }
                }

                // å¤„ç† buffer ä¸­å‰©ä½™çš„æ•°æ®
                if (buffer.trim()) {
                    const lines = buffer.split('\n');
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const dataStr = line.slice(6);
                            try {
                                const data = JSON.parse(dataStr);
                                if (data.token) {
                                    accumulatedText += data.token;
                                    updateMessage(assistantContentDiv, accumulatedText);
                                }
                            } catch (e) {
                                console.error('Parse error on buffer:', e);
                            }
                        }
                    }
                }

            } catch (error) {
                console.error('Error:', error);
                assistantContentDiv.innerHTML = '<p style="color: #ff0000;">è¯·æ±‚å¤±è´¥: ' + error.message + '</p>';
            } finally {
                sendButton.disabled = false;
                userInput.focus();
            }
        }

        // äº‹ä»¶ç›‘å¬
        sendButton.addEventListener('click', sendMessage);
        
        userInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // åˆå§‹åŒ–ï¼šèšç„¦è¾“å…¥æ¡†
        userInput.focus();
    </script>
</body>
</html>

